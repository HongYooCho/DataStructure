### Hashing
* Search, Delete, Insert: O (1)
* Hash Function을 사용함으로써 함수를 돌려서 나온 결과를 인덱스로 하여 값을 얻는다
1. Static Hashing
* Hash Table을 가지고 있으며, 버킷이 있다. (키가 중복되는 경우(collision) 이 곳에 저장)
* Overflow가 발생할 수 있다. 버킷 사이즈를 넘겨 중복되는 경우

### Ultimate Objective of Hashing
1. 콜리션 수를 최소화 하자: 해쉬 테이블의 키들을 골고루 분배
2. 오버플로우를 최소화 하자: 콜리션을 최소화하고, 인덱스당 버킷을 늘리자
3. Hash Table의 사이즈를 줄이자: 너무 크면 공간 낭비가 크고, 너무 작으면 collision이 많이 일어남

### 해싱의 두개의 핵심 요소
1. 해쉬 함수를 고르는 것: 콜리젼과 오버플로우를 최소화 하자, 계산을 쉽게 하자
2. 충돌 수를 줄이는 것
* 제한된 공간에서 콜리션은 피할 수 없는 것이다.
* 충돌한 키를 저장하고 검색

### Hash Functions
1. Division Function
* %연산을 사용하여 나온 값을 키로 하는 것
* Hash table 사이즈에 맞춰서 저장하는 것을 보장 할 수 있음
2. 스트링인 경우, 그것을 자연수로 바꿔서 키로 설정하는 방법

### Collision Resolution
1. Open addressing: Hash table 내에서 끝내도록 하는거
- Linear Probing: 간단하게 이미 있으면 다른 빈 집을 찾아보는 것.
 <br>리니어하게 쭉 서치를 하고 empty 공간을 찾아 그곳에 집어넣는다.
* Linear Probing의 문제
```
Small problem 해쉬 테이블이 꽉찰 경우?
해쉬 사이즈를 늘려야하는데 그럴 경우 % 연산도 다시해야하고 결국 버킷에 있는 것들도 다바꿔야하는 경우가 발생 -> 오버헤드가 크다.

또한 버킷이 비워져있을 때 서치를 멈출 수도 있다.
예를들어 a와 b가 해쉬를 했을 때 같은 값이 나와서 b가 리니어하게 다른 곳에 들어가있는 상황이다. 그때 a는 지워지고 b를 서치 하려고 하는데 b의 해쉬값은 a와 같은 값이므로 비어있는 곳을 서치하는 상황이 발생

해결방법
1. 각 인덱스에 3개의 상태를 부여
 1) Occupied -> 계속 찾아봐라
 2) Empty -> 키 값을 넣어라
 3) Deleted -> 키를 넣는 연산이면 넣고, 서치용이면 계속 찾아보게 시키자

Big Problem
콜리션 나서 리니어하게 서치를 하고 빈집에 들어가는데 그 빈집은 원래 누군가 다른 사람의 집이다. 이렇게 계속 누군가의 집에 침범하듯이 들어가게 되면 서치 시간 복잡도는 계속 해서 증가하게됨 (이유: 해쉬 펑션돌려서 키를 찾는데 다른 것들만 나오므로 리니어하게 또 서치를 해야함)
또한 리니어하게 인서트를 하게되므로 한 영역에서만 데이터가 뭉치는 현상이 일어난다.

해결 방법
멀리 떨어져 있는 공간을 찾고 거기에 삽입을 하자.
부분적으로 데이터가 뭉쳐지려는 문제를 해결할 수 있다.
```
- Quadratic Probing
* 비어있는 집을 찾을 때 하나씩 움직이는 것이 아닌 제곱 수로 움직이는 것
* 1 4 9로 이동하면서 데이터를 집어 넣음
- Double Hashing
* 첫번째 해쉬 함수가 콜리션이 일어나면 두번째 해쉬 함수로 다시 인덱스를 찾는다.
* 두번째 해쉬함수는 첫번째에서 콜리션이 난 경우, 콜리션 난것에서부터 인덱스의 간격을 나타내주는 함수이다.

### Closed Addressing
1. Full 2D array for the HT: 간단하게 버킷을 더 늘려서 저장하는 것
2. Overflow chaining
- 오버플로우가 날경우 해당 키에 링크드 리스트로 연결하는 것을 의미
